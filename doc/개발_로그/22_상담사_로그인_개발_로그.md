# 상담사 로그인 기능 개발 로그

## 프로젝트 정보
- **프로젝트명**: SCMS (Student Counseling Management System)
- **개발 브랜치**: claude/counselor-login-dev-log-019YsQZJojjFoiALTiqby2Hq
- **개발 기간**: 2025년 11월
- **담당**: Claude AI Assistant

---

## 목차
1. [개요](#개요)
2. [시스템 아키텍처](#시스템-아키텍처)
3. [개발 일정 및 커밋 히스토리](#개발-일정-및-커밋-히스토리)
4. [주요 기능 구현](#주요-기능-구현)
5. [기술적 문제 및 해결 방법](#기술적-문제-및-해결-방법)
6. [보안 설정](#보안-설정)
7. [테스트 및 검증](#테스트-및-검증)
8. [향후 개선사항](#향후-개선사항)

---

## 개요

### 목적
학생 상담 관리 시스템(SCMS)에서 상담사(Counselor)가 안전하게 로그인하고 상담 업무를 수행할 수 있는 인증 시스템 구현

### 주요 요구사항
- 상담사 계정 자동 생성 및 초기화
- 학번 기반 로그인 시스템
- 역할 기반 접근 제어 (RBAC)
- 계정 보안 (로그인 실패 시 자동 잠금)
- 세션 기반 인증
- 최초 로그인 시 비밀번호 변경 유도

---

## 시스템 아키텍처

### 엔티티 관계도

```
User (PK: userId)
├─ userId (학번 기반 고유 ID)
├─ studentNum (학번, 8000001-8000002)
├─ role (STUDENT, COUNSELOR, ADMIN)
├─ password (BCrypt 암호화)
├─ locked (계정 잠금 여부)
├─ failCnt (로그인 실패 횟수)
└─ deletedAt (Soft Delete)

Counselor (PK: counselorId)
├─ counselorId (User.userId와 동일, @MapsId)
├─ user (User와 @OneToOne 관계)
├─ specialty (전문분야)
├─ introduction (자기소개)
└─ deletedAt (Soft Delete)
```

### 주요 컴포넌트

#### Controller Layer
- **AuthController** (`src/main/java/com/scms/app/controller/AuthController.java`)
  - `/api/auth/login`: 로그인 처리
  - `/api/auth/logout`: 로그아웃 처리
  - `/api/auth/me`: 현재 사용자 정보 조회
  - `/api/auth/password/change`: 비밀번호 변경
  - `/api/auth/password/reset`: 비밀번호 재설정

#### Service Layer
- **UserService** (`src/main/java/com/scms/app/service/UserService.java`)
  - 로그인 인증 로직
  - 비밀번호 검증 (BCrypt)
  - 로그인 실패 횟수 관리
  - 계정 잠금 처리

- **CounselorService** (`src/main/java/com/scms/app/service/CounselorService.java`)
  - 상담사 프로필 조회
  - 상담사 일정 관리
  - 전문분야별 검색

#### Repository Layer
- **UserRepository** (`src/main/java/com/scms/app/repository/UserRepository.java`)
- **CounselorRepository** (`src/main/java/com/scms/app/repository/CounselorRepository.java`)

#### Config Layer
- **SecurityConfig** (`src/main/java/com/scms/app/config/SecurityConfig.java`)
  - Spring Security 설정
  - 역할 기반 접근 제어
  - 세션 관리

- **DataLoader** (`src/main/java/com/scms/app/config/DataLoader.java`)
  - 초기 데이터 로딩
  - 상담사 계정 자동 생성

---

## 개발 일정 및 커밋 히스토리

### Phase 1: 기본 구조 및 보안 설정
**날짜**: 2025-11-15 ~ 2025-11-16

| 커밋 해시 | 날짜 | 설명 |
|-----------|------|------|
| d2d1805 | 11-16 | security: Add role-based access control for counselor endpoints |
| bbdd50e | 11-16 | fix: Ensure counselor profiles are created for existing counselor users |

**주요 작업**:
- Spring Security 설정
- 역할 기반 접근 제어 구현
- Counselor 엔티티 설계

---

### Phase 2: 데이터 초기화 문제 해결
**날짜**: 2025-11-16 ~ 2025-11-17

| 커밋 해시 | 날짜 | 설명 |
|-----------|------|------|
| d608cd3 | 11-16 | fix: Add counselor account initialization in DataLoader |
| 217352c | 11-16 | fix: Update counselor password hash to correct BCrypt format |
| f522bd1 | 11-17 | fix: Ensure counselor accounts are created even when users exist |
| fed64b4 | 11-17 | docs: Add counselor login troubleshooting guide |

**주요 작업**:
- DataLoader에서 상담사 계정 자동 생성 로직 구현
- BCrypt 비밀번호 해시 형식 수정
- 기존 사용자가 있을 때도 Counselor 프로필 생성 보장
- 문제 해결 가이드 작성

**발생한 문제**:
- BCrypt 해시가 잘못된 형식으로 저장되어 로그인 실패
- DataLoader가 기존 사용자를 무시하고 새 계정 생성 시도

---

### Phase 3: Hibernate 관계 매핑 문제 해결
**날짜**: 2025-11-17 ~ 2025-11-18

| 커밋 해시 | 날짜 | 설명 |
|-----------|------|------|
| 8c90581 | 11-17 | fix: Correct database schema for counselors table |
| 4d90b0d | 11-17 | fix: Remove explicit counselorId setting when using @MapsId |
| 2f6f7ac | 11-18 | fix: Remove cascade from Counselor.user to prevent detached entity error |
| 9eefaf7 | 11-18 | fix: Use EntityManager to get managed User entity |
| e963c9a | 11-18 | fix: Use JDBC to insert Counselor profiles to avoid Hibernate cascade issues |

**주요 작업**:
- `@MapsId` 사용 시 counselorId 명시적 설정 제거
- Counselor.user 관계에서 cascade 설정 제거
- EntityManager를 사용한 managed entity 처리 시도
- 최종적으로 JDBC를 사용한 직접 SQL 삽입으로 해결

**발생한 문제** (상세는 다음 섹션 참조):
- Detached entity 에러
- Cascade 처리 복잡성
- Hibernate와 데이터베이스 스키마 불일치

---

## 주요 기능 구현

### 1. 로그인 시스템

#### 로그인 플로우
```
1. 사용자가 학번과 비밀번호 입력
   ↓
2. UserService.login() 호출
   ↓
3. 학번으로 사용자 조회
   ↓
4. 계정 잠금 여부 확인
   ↓
5. BCrypt로 비밀번호 검증
   ↓
6. 로그인 성공 시:
   - failCnt 초기화
   - 세션 생성
   - SecurityContext에 인증 정보 저장
   - 로그인 이력 저장
   ↓
7. 로그인 실패 시:
   - failCnt 증가
   - failCnt >= 5이면 계정 잠금
```

#### 코드 스니펫 (`UserService.java:login()`)
```java
public LoginResponse login(LoginRequest request, HttpServletRequest httpRequest) {
    // 1. 학번으로 사용자 조회
    User user = userRepository.findByStudentNumAndNotDeleted(request.getStudentNum())
        .orElseThrow(() -> new UserNotFoundException("사용자를 찾을 수 없습니다."));

    // 2. 계정 잠금 확인
    if (user.getLocked()) {
        throw new AccountLockedException("계정이 잠겨있습니다. 관리자에게 문의하세요.");
    }

    // 3. 비밀번호 검증
    if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
        user.setFailCnt(user.getFailCnt() + 1);
        if (user.getFailCnt() >= 5) {
            user.setLocked(true);
        }
        userRepository.save(user);
        throw new InvalidPasswordException("비밀번호가 일치하지 않습니다.");
    }

    // 4. 로그인 성공 처리
    user.setFailCnt(0);
    userRepository.save(user);

    // 5. 로그인 이력 저장
    saveLoginHistory(user, httpRequest);

    // 6. 최초 로그인 여부 확인 (생년월일 6자리 == 비밀번호)
    boolean isFirstLogin = isDefaultPassword(request.getPassword(), user);

    return LoginResponse.from(user, isFirstLogin);
}
```

---

### 2. 상담사 계정 자동 생성

#### DataLoader 초기화 로직
```java
@PostConstruct
public void init() {
    initializeCounselors();
}

private void initializeCounselors() {
    // 1. 기존 상담사 사용자 조회
    List<User> counselorUsers = userRepository.findByRoleAndNotDeleted(UserRole.COUNSELOR);

    // 2. Counselor 프로필이 없는 경우 생성
    for (User counselorUser : counselorUsers) {
        boolean hasProfile = counselorRepository.findById(counselorUser.getUserId()).isPresent();
        if (!hasProfile) {
            // JDBC를 사용한 직접 INSERT
            jdbcTemplate.update(
                "INSERT INTO counselors (counselor_id, special, intro, created_at, updated_at) " +
                "VALUES (?, ?, ?, NOW(), NOW())",
                counselorUser.getUserId(),
                "일반상담",
                "학생 상담을 담당하고 있습니다."
            );
            log.info("상담사 프로필 생성: userId={}", counselorUser.getUserId());
        }
    }

    // 3. 상담사가 없으면 새로 생성
    if (counselorUsers.isEmpty()) {
        createCounselors();
    }
}

private void createCounselors() {
    // 김상담 (학번: 8000001)
    User counselor1 = createCounselorUser(
        8000001, "김상담", "counselor1@pureum.ac.kr",
        "010-1234-5678", "counselor123"
    );
    createCounselorProfile(counselor1, "진로상담, 학업상담");

    // 이상담 (학번: 8000002)
    User counselor2 = createCounselorUser(
        8000002, "이상담", "counselor2@pureum.ac.kr",
        "010-2345-6789", "counselor123"
    );
    createCounselorProfile(counselor2, "심리상담, 대인관계");
}
```

---

### 3. 역할 기반 접근 제어 (RBAC)

#### SecurityConfig 설정
```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(auth -> auth
            // 인증 없이 접근 가능
            .requestMatchers("/api/auth/**").permitAll()
            .requestMatchers("/login", "/css/**", "/js/**").permitAll()

            // 관리자만 접근 가능
            .requestMatchers("/api/users/**").hasRole("ADMIN")

            // 상담사 또는 관리자만 접근 가능
            .requestMatchers("/counseling/manage").hasAnyRole("COUNSELOR", "ADMIN")
            .requestMatchers("/api/consultations/*/record").hasRole("COUNSELOR")

            // 나머지는 인증 필요
            .anyRequest().authenticated()
        )
        .csrf(csrf -> csrf.disable())
        .formLogin(form -> form.disable())
        .httpBasic(basic -> basic.disable())
        .securityContext(context -> context
            .securityContextRepository(securityContextRepository())
        );

    return http.build();
}
```

---

## 기술적 문제 및 해결 방법

### 문제 1: Detached Entity Error

#### 증상
```
org.hibernate.PersistentObjectException: detached entity passed to persist
```

Counselor 엔티티 저장 시 User 엔티티가 detached 상태로 인식되어 에러 발생

#### 원인 분석
1. `User` 엔티티가 이미 데이터베이스에 저장되어 있음 (persisted 상태)
2. `Counselor` 엔티티 생성 시 `User`를 참조
3. `@OneToOne(cascade = CascadeType.ALL)` 설정으로 인해 Hibernate가 User를 다시 persist 시도
4. 이미 존재하는 User를 persist하려고 하여 detached entity 에러 발생

#### 시도한 해결 방법

##### 시도 1: EntityManager를 사용한 Managed Entity 가져오기
```java
// 커밋: 9eefaf7
User managedUser = entityManager.find(User.class, counselorUser.getUserId());
Counselor counselorProfile = Counselor.builder()
    .user(managedUser)
    .specialty("일반상담")
    .introduction("학생 상담을 담당하고 있습니다.")
    .build();
counselorRepository.save(counselorProfile);
```

**결과**: 여전히 에러 발생. EntityManager가 다른 persistence context를 사용하거나, transaction 경계 문제로 추정

##### 시도 2: Cascade 제거
```java
// 커밋: 2f6f7ac
@OneToOne(fetch = FetchType.LAZY, cascade = {})
@MapsId
@JoinColumn(name = "counselor_id")
private User user;
```

**결과**: cascade 문제는 해결되었으나, DataLoader에서 User가 managed 상태가 아니어서 여전히 문제 발생

#### 최종 해결 방법: JDBC 직접 사용

```java
// 커밋: e963c9a
jdbcTemplate.update(
    "INSERT INTO counselors (counselor_id, special, intro, created_at, updated_at) " +
    "VALUES (?, ?, ?, NOW(), NOW())",
    counselorUser.getUserId(),
    "일반상담",
    "학생 상담을 담당하고 있습니다."
);
```

**장점**:
- Hibernate의 복잡한 상태 관리 회피
- 단순하고 명확한 SQL 실행
- 트랜잭션 경계 문제 없음
- 성능상 이점 (ORM 오버헤드 없음)

**단점**:
- ORM의 이점 상실 (타입 안정성, 자동 매핑 등)
- SQL 직접 관리 필요

**의사결정**:
초기화 코드는 애플리케이션 시작 시 한 번만 실행되고, 복잡한 비즈니스 로직이 없으므로 JDBC 사용이 적절하다고 판단

---

### 문제 2: @MapsId 사용 시 ID 중복 설정

#### 증상
```java
Counselor counselor = Counselor.builder()
    .counselorId(user.getUserId())  // 명시적 설정
    .user(user)
    .build();
```

`@MapsId`를 사용하면 `user.userId`가 자동으로 `counselorId`로 매핑되는데, 명시적으로 `counselorId`를 설정하여 충돌 발생

#### 해결 방법 (커밋: 4d90b0d)
```java
Counselor counselor = Counselor.builder()
    // .counselorId() 제거
    .user(user)
    .specialty(specialty)
    .introduction(introduction)
    .build();
```

`@MapsId` 사용 시 ID를 명시적으로 설정하지 않음

---

### 문제 3: 데이터베이스 스키마 불일치

#### 증상
Counselor 테이블의 컬럼명이 JPA 엔티티와 일치하지 않아 데이터 매핑 실패

#### 원인
- 엔티티: `specialty`, `introduction`
- 데이터베이스: `special`, `intro`

#### 해결 방법 (커밋: 8c90581)
```java
@Column(name = "special")
private String specialty;

@Column(name = "intro", length = 1000)
private String introduction;
```

`@Column(name = "...")` 애노테이션으로 명시적 매핑

---

### 문제 4: BCrypt 해시 형식 오류

#### 증상
로그인 시 "비밀번호가 일치하지 않습니다" 에러 발생

#### 원인
BCrypt 해시가 잘못된 형식으로 저장됨:
- 올바른 형식: `$2a$10$...` (60자)
- 잘못된 형식: 평문 또는 다른 해시 알고리즘

#### 해결 방법 (커밋: 217352c)
```java
String encodedPassword = passwordEncoder.encode("counselor123");
// $2a$10$VQy5sY8xJ... (60자의 BCrypt 해시)

User counselor = User.builder()
    .password(encodedPassword)  // 평문이 아닌 BCrypt 해시 사용
    .build();
```

---

## 보안 설정

### 1. 비밀번호 암호화
- **알고리즘**: BCrypt
- **비용 계수**: 10 (기본값)
- **해시 길이**: 60자

```java
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}
```

### 2. 계정 잠금 정책
- 로그인 실패 5회 이상 시 계정 자동 잠금
- 잠금 해제는 관리자만 가능

### 3. 세션 관리
- HttpSession 기반 인증
- Spring Security SecurityContext와 통합
- 세션 만료 시 자동 로그아웃

### 4. CSRF 보호
- 개발 단계에서는 비활성화
- 프로덕션 배포 시 활성화 필요

### 5. 역할 기반 접근 제어
| 엔드포인트 | 허용 역할 |
|------------|-----------|
| /api/auth/** | 모두 |
| /api/users/** | ADMIN |
| /counseling/manage | COUNSELOR, ADMIN |
| /api/consultations/*/record | COUNSELOR |

---

## 테스트 및 검증

### 1. 수동 테스트

#### 로그인 테스트
```bash
# 성공 케이스
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"studentNum": 8000001, "password": "counselor123"}'

# 예상 응답:
{
  "userId": 123,
  "studentNum": 8000001,
  "name": "김상담",
  "role": "COUNSELOR",
  "isFirstLogin": false
}

# 실패 케이스 (잘못된 비밀번호)
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"studentNum": 8000001, "password": "wrong"}'

# 예상 응답:
{
  "error": "비밀번호가 일치하지 않습니다."
}
```

#### 상담사 목록 조회
```bash
curl -X GET http://localhost:8080/api/counselors \
  -H "Cookie: JSESSIONID=..."

# 예상 응답:
[
  {
    "counselorId": 123,
    "name": "김상담",
    "email": "counselor1@pureum.ac.kr",
    "specialty": "진로상담, 학업상담"
  },
  {
    "counselorId": 124,
    "name": "이상담",
    "email": "counselor2@pureum.ac.kr",
    "specialty": "심리상담, 대인관계"
  }
]
```

### 2. 데이터베이스 검증

```sql
-- 상담사 계정 확인
SELECT u.user_id, u.student_num, u.name, u.role, c.special, c.intro
FROM users u
LEFT JOIN counselors c ON u.user_id = c.counselor_id
WHERE u.role = 'COUNSELOR' AND u.deleted_at IS NULL;

-- 예상 결과:
-- user_id | student_num | name   | role      | special             | intro
-- 123     | 8000001     | 김상담 | COUNSELOR | 진로상담, 학업상담  | ...
-- 124     | 8000002     | 이상담 | COUNSELOR | 심리상담, 대인관계  | ...
```

### 3. 로그 확인

```bash
# 상담사 계정 생성 로그
tail -f logs/application.log | grep "상담사"

# 예상 로그:
# 상담사 계정 생성: 김상담 (학번: 8000001, 비밀번호: counselor123)
# 상담사 계정 생성: 이상담 (학번: 8000002, 비밀번호: counselor123)
# 상담사 프로필 생성: userId=123
# 상담사 프로필 생성: userId=124
```

---

## 향후 개선사항

### 1. 단위 테스트 및 통합 테스트 추가
```java
@SpringBootTest
class CounselorLoginTest {

    @Test
    void testCounselorLogin_Success() {
        // Given
        LoginRequest request = new LoginRequest(8000001, "counselor123");

        // When
        LoginResponse response = userService.login(request, mockRequest);

        // Then
        assertEquals("김상담", response.getName());
        assertEquals(UserRole.COUNSELOR, response.getRole());
    }

    @Test
    void testAccountLocking_After5FailedAttempts() {
        // ...
    }
}
```

### 2. 비밀번호 정책 강화
- 최소 길이 8자 이상
- 대문자, 소문자, 숫자, 특수문자 조합
- 정기적인 비밀번호 변경 알림

### 3. 2단계 인증 (2FA)
- 이메일 또는 SMS 기반 OTP
- Google Authenticator 연동

### 4. 로그인 이력 조회 기능
- 상담사가 자신의 로그인 이력 확인
- 의심스러운 활동 감지 및 알림

### 5. 세션 관리 개선
- Redis를 사용한 분산 세션 관리
- 동시 로그인 제한 (1개 세션만 허용)

### 6. CSRF 보호 활성화
프로덕션 환경에서는 CSRF 토큰 활성화 필요

### 7. API Rate Limiting
무차별 대입 공격(Brute Force) 방지를 위한 요청 속도 제한

### 8. 감사 로그 (Audit Log)
- 상담사의 모든 활동 기록
- 데이터 접근 이력 추적
- 규정 준수 (Compliance)

---

## 참고 자료

### 관련 문서
- [상담사 로그인 가이드](./상담사_로그인_문제_해결.md)

### 주요 파일 목록
| 파일 경로 | 설명 |
|-----------|------|
| `src/main/java/com/scms/app/model/User.java` | User 엔티티 |
| `src/main/java/com/scms/app/model/Counselor.java` | Counselor 엔티티 |
| `src/main/java/com/scms/app/controller/AuthController.java` | 인증 컨트롤러 |
| `src/main/java/com/scms/app/service/UserService.java` | 사용자 서비스 |
| `src/main/java/com/scms/app/service/CounselorService.java` | 상담사 서비스 |
| `src/main/java/com/scms/app/config/SecurityConfig.java` | Spring Security 설정 |
| `src/main/java/com/scms/app/config/DataLoader.java` | 초기 데이터 로더 |

### 데이터베이스 스키마
```sql
-- users 테이블
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    student_num INT UNIQUE NOT NULL,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(20),
    password VARCHAR(255) NOT NULL,
    role ENUM('STUDENT', 'COUNSELOR', 'ADMIN') NOT NULL,
    locked BOOLEAN DEFAULT FALSE,
    fail_cnt INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL
);

-- counselors 테이블
CREATE TABLE counselors (
    counselor_id INT PRIMARY KEY,
    special VARCHAR(255),
    intro TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL,
    FOREIGN KEY (counselor_id) REFERENCES users(user_id) ON DELETE CASCADE
);
```

---

## 결론

상담사 로그인 기능은 다음과 같은 핵심 요소를 성공적으로 구현했습니다:

1. **자동화된 계정 생성**: DataLoader를 통한 상담사 계정 자동 초기화
2. **안전한 인증**: BCrypt 비밀번호 암호화, 계정 잠금, 세션 관리
3. **역할 기반 접근 제어**: Spring Security를 활용한 RBAC 구현
4. **기술적 문제 해결**: Hibernate detached entity 문제를 JDBC로 우회하여 해결

개발 과정에서 발생한 여러 기술적 문제들을 체계적으로 분석하고 해결하며, 각 해결 방법의 장단점을 고려한 의사결정을 수행했습니다. 특히 Hibernate와 JPA의 복잡한 상태 관리 문제를 단순한 JDBC 접근 방식으로 해결한 것은 "간단한 것이 최선"이라는 원칙을 보여줍니다.

향후 프로덕션 배포를 위해서는 추가적인 보안 강화(CSRF 보호, 2FA, Rate Limiting 등)와 테스트 코드 작성이 필요합니다.

---

**작성일**: 2025-11-18
**작성자**: Claude AI Assistant
**버전**: 1.0
